# Flatbuffer Tutorial

This is a small tutorial on how to use flatbuffers in python.
Please also consider the flatbuffer documentation which offers a lot of information on the topic and examples for all supported languages.

## Installation

For using the flatbuffer you need to install ``flatc``,
which is an compiler fpr translating your schema into POJO like classes which can be used in your code.
You can either build the flatbuffer compiler from source or use vcpkg to install it.
This repo does contain the current flatbuffer repo as a submodule, so you don't need to clone it separately.

### Install flatc

```bash
git submodule update --init --recursive
cd flatbuffers
cmake -DCMAKE_BUILD_TYPE=Release
make
```


### install flatbuffer python package

```bash
pip install flatbuffers
```

## Usage

### Create a schema

The first step is to define a schema which provides the information on how to serialize your data.  
The schema is defined in a ``.fbs`` file and the dsl for this reminds a bit of c or c++.
Let's take a look at the schema for the example below:

```flatbuffers

// Example IDL file for our monster's schema.
 
namespace MyGame.Sample;
 
enum Color:byte { Red = 0, Green, Blue = 2 }
 
union Equipment { Weapon } // Optionally add more tables.
 
struct Vec3 {
  x:float;
  y:float;
  z:float;
}
 
table Monster {
  pos:Vec3; // Struct.
  mana:short = 150;
  hp:short = 100;
  name:string;
  friendly:bool = false (deprecated);
  inventory:[ubyte];  // Vector of scalars.
  color:Color = Blue; // Enum.
  weapons:[Weapon];   // Vector of tables.
  equipped:Equipment; // Union.
  path:[Vec3];        // Vector of structs.
}
 
table Weapon {
  name:string;
  damage:short;
}
 
root_type Monster;

```

### Generate the code

The next step is to generate the code for the schema.
Using the flatbuffer compiler ``flatc --python schema.fbs`` will generate a new python module wich is named after your namespace.

### Build our monster

We first have to import the generated module as well as the flatbuffers module.

```python
import flatbuffers
 
# Generated by `flatc`.
import MyGame.Sample.Color
import MyGame.Sample.Equipment
import MyGame.Sample.Monster
import MyGame.Sample.Vec3
import MyGame.Sample.Weapon
```
we first begin to serialize a simple weapon for our game.
For example a sword with 3 damage.
For this we first need to create a builder which will be used to serialize our data.
We give our builder a buffer size of 1024 bytes. However, this buffer is dynamically resized if it is too small.
```python
# Create a builder.
builder = flatbuffers.Builder(1024)
```

now we create our weapons. For the sake of reprocity we capture this in a function.
```python
def create_weapon(builder, name, damage):
    # Create the name.
    name_offset = builder.CreateString(name)
    # Create the weapon.
    MyGame.Sample.Weapon.WeaponStart(builder)
    MyGame.Sample.Weapon.WeaponAddName(builder, name_offset)
    MyGame.Sample.Weapon.WeaponAddDamage(builder, damage)
    return MyGame.Sample.Weapon.WeaponEnd(builder)

sword = create_weapon(builder, "Sword", 3)
axe = create_weapon(builder, "Axe", 5)
``` 


As you can see we first have to serialize the string and can't just pass it to the builder.
So to create more complex objects such as Weapon we need to first serialize any objects that are contained therein, i.e. we serialize the data tree using depth-first, pre-order traversal. This is generally easy to do on any tree structures.

Lets create a monster named "Orc". This object contains Vectors, structs and also tables and we need to serialize each of these in the correct order.

First we create it's inventory.
```python
# Create the inventory.
def create_inventory(builder, size: int):
    # Create the inventory.
    MyGame.Sample.Monster.StartInventoryVector(builder, size)
    for i in range(size):
        builder.PrependByte(i)
    return builder.EndVector(size)
inv = create_inventory(builder, 10)
```

We serialized two built-in data types (string and vector) and captured their return values. These values are offsets into the serialized data, indicating where they are stored, such that we can refer to them below when adding fields to our monster.


We can also create the weapons vector as we have already serialized the weapons.
```python
# Create the weapons.
def insert_weapons(builder, weapons):
    # Create the weapons.
    MyGame.Sample.Monster.StartWeaponsVector(builder, len(weapons))
    for weapon in weapons:
        builder.PrependUOffsetTRelative(weapon)
    return builder.EndVector(len(weapons))
weapons = insert_weapons(builder, [sword, axe])
```


